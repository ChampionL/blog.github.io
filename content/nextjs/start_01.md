# nextjs入门

1. `npx create-next-app@latest` 创建项目
2. 在app目录下建立新目录  app/dashboard/settings
3. 在settings下建立 page.tsx
4. 在页面中输入typescript页面
    ```typescript 
    export default function Page() {
        return <h1 className={"text-3xl text-orange-500"}>Hello,NextJS</h1>
    }
   ```
5. 指向npm run dev可以看到效果，注意去除global.css中无用样式
6. 在layout.tsx中配置  生效，在page.tsx修改Title不会生效
  ```typescript
      export const metadata: Metadata = {
      title: "Next.js",
      description: "Generated by create next app",
      };
   ```
7. 使用link几种方式
使用Link组件
   export default function Home() {
        return <Link href="/dashboard">Dashboard</Link>
   }
    href写指向跳转的连接
8. 目录名如果是(shop) 加括号，则说明是路由组，不参与实际调度，可以定义自己的layout 也会继成父亲节点的layout
9. 动态路由
   动态路由意思是使用 [folderName] For example, [id] or [slug].
   建立 app/blog/[slug]/page.js 文件 
   page.js里面填充以下内容
   ```typescript
    export default function Page({ params }: { params: { slug: string } }) {
        return <div>My Post: {params.slug}</div>
    }
    ```
   在匹配 /blog/a 路径时候会形成参数 {slug:'a'}  
   在匹配 /blog/b 路径时候会形成参数 {slug:'b'}
   [...folderName] For example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on
   可以匹配一个segment或者两个，或者三四个
   [[...folderName]] For example, app/shop/[[...slug]]/page.js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts
   双括号和单括号区别在于[[]]是可选，可以匹配segment也可以不匹配
   app/shop/[[...slug]]/page.js	/shop	{}
   app/shop/[[...slug]]/page.js	/shop/a	{ slug: ['a'] }
10. Loading加载页面
  ```
          <Suspense fallback={<Loading />}>
              RootLayout
              {children}
          </Suspense>
          Suspense 悬停，在RootLayout {children} 渲染完成之前会显示Loading函数，loading.js中的
          
         -------------------
         export default function Loading() {
            return "Loading..."
         }
  ```
11. page.tsx是唯一对外展示的文件  layout.tsx是为了方便多个页面之间共享组件 放在layout.tsx的文件可以实现共享
12. 使用next.js的Link 而不是a 可以实现部分页面刷新，导航侧边栏不刷新，而是整个页面刷新
13. 使用clsx修改className
   ```
           className={clsx("flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3",{
                  'bg-sky-100 text-blue-600': pathname === link.href
            },
   ```
14. node.js使用 ``` const  {numberOfCustomers,numberOfInvoices, totalPaidInvoices,totalPendingInvoices} = await fetchCardData()``` 多个变量接受需要使用{}来接受
15. route group可以用来隔离loading的使用，使其不在子模块上使用
16. CardWrapper 就是将多个Card合并在一起作为一个函数来展示，而不是单独每个Card单独展示
17. REACT使用指引 https://zh-hans.react.dev/learn
18. JSX 会让你把标签放到 JavaScript 中。而大括号会让你 “回到” JavaScript 中，这样你就可以从你的代码中嵌入一些变量并展示给用户 你还可以将 JSX 属性 “转义到 JavaScript”，但你必须使用大括号 而非
19. export default function Square() {
    return(<>
    <button className="square">X</button>
    <button className="square">X</button>
    </>)
    }
    return返回多个button 除了需要用<></>来包裹外，还需要使用()来包裹
20. JavaScript 支持闭包，这意味着内部函数（例如 handleClick）可以访问外部函数（例如 Board）中定义的变量和函数。handleClick 函数可以读取 squares state 并调用 setSquares 方法，因为它们都是在 Board 函数内部定义的。
21.  web布局  
`fixed布局`: 元素的位置和大小都是预先固定的，不随用户设备的分辨率和屏幕尺寸变化而改变。固定布局常用于需要精确控制页面布局和元素位置的场合.这样做可以使元素相对于浏览器窗口固定，不受页面滚动的影响.
          `使用CSS的position属性和top、left、right、bottom属性来固定元素的位置`
`flex布局`:  主轴默认是水平方向
justify-content: 控制水平方向分布，有
- flex-start：项目在主轴起始位置对齐。
- flex-end：项目在主轴末尾位置对齐
- center：项目在主轴居中对齐，空白空间会分布在左右两侧，项目居中。
- space-between：项目在主轴上均匀分布，首个项目位于起始位置，末尾项目位于末尾位置，中间的项目之间有相等的空白间隔
- space-around：项目在主轴上均匀分布，项目之间有相等的空白间隔，项目的两侧空白间隔是项目之间空白间隔的一半
- space-evenly：项目在主轴上均匀分布，项目之间和项目的两侧空白间隔相等
flex布局练习  https://flexboxfroggy.com/
  justify-content:  控制主轴方向元素分布，默认主轴是水平
  align-items: 控制交叉轴方向元素分布，默认交叉轴是垂直方向.控制的是垂直方向上子元素与子元素对齐方式，右子元素上边框对齐，成为start 子元素下边框对齐，称为end.子元素中心对齐称为center.
                大部分时候都市stretch伸缩，所以flex元素之前不相等或者有相互扩充成方向时候，可以调整钙元素
  flex-direction: 定义主轴的方向，row,row-reverse,column,column-reverse 水平从左到右 水平从右到左 垂直从上到下  垂直从下到上
  order: 控制元素的展示顺序，未某个具体元素指定，-2,1,0,1,2
  align-self: 单独控制自己的对其顺序，控制交叉轴
  flex-wrap: wrap,wrap-reverse  换行,从左到右， 方向换行，从右到左
  flex-flow: flex-direction 和 flex-wrap的结合:
  align-content： 控制交叉轴上行与行之间的分布。控制多行 flex 项目在交叉轴上的对齐方式。

flex 默认将每个元素设置为块元素，占据全部宽度

flex-grow flex-grow 
属性控制子元素在剩余空间分配时的扩展比例。它接受一个非负整数值，默认为 0。当所有子元素的 flex-grow 值为 0 时，它们将不会分配剩余空间。当子元素的 flex-grow 值大于 0 时，它们会根据其 flex-grow 值的比例分配剩余空间。例如，如果一个子元素的 flex-grow 值为 2，另一个子元素的 flex-grow 值为 1，那么前者将获得的剩余空间将是后者的两倍。

relative: position布局
相对定位是指元素相对于其正常位置进行偏移，而不会影响其他元素的布局。使用相对定位，可以通过设置 top、bottom、left 和 right 属性来控制元素在水平和垂直方向上的偏移量。 

HTML <section> 元素表示 HTML 文档中一个通用独立章节，它没有更具体的语义元素来表示。一般来说会包含一个标题。

/public 路径下的文件 和 app目录下共享/这个路径  如果在favicon.ico 都在这两个目录下放，nextjs会无法确定使用哪一个图标，因此会报错。

<Image src='/images/header-logo.svg' alt='log' width='64' height='64'></Image>  需要指定长度和宽度 Image会以public为静态资源root来寻找

gap-16 设置flex子元素之间间隔为16px

absolute 和 fixed 都会将元素脱离文档流  fixed的位置基准是整个视口  absolute是相对于最近的非 static 定位祖先元素的偏移

22. next-js中对于新建的目录 如果要生效 tailwindcss样式，注意  tailwind.config.ts的content中添加路径 ""./sections/**/*.{js,ts,jsx,tsx,mdx}" 否则会不生效
